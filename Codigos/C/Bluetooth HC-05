#define F_CPU 16000000UL // Frecuencia del CPU

#include <avr/io.h>
#include <util/delay.h>

#define BAUD 9600 //105 para 9600 - 26 para 38400
#define MY_UBRR F_CPU/16/BAUD-1

#define AT_delay 25.2 // 25.275 me gustó
#define GPIO_delay 104 // 105


#define TX_PIN PB0
#define RX_PIN PB1

void initSerial() {
	// Configura PB0 como salida (TX)
	DDRB |= (1 << TX_PIN);
	// Configura PB1 como entrada (RX)
	DDRB &= ~(1 << RX_PIN);
}

void sendByteGPIO(uint8_t data) {
	// Enviar un byte a través de PB0 (TX)
	PORTB &= ~(1 << TX_PIN); // Start bit
	_delay_us(GPIO_delay); // Esperar

	for (int i = 0; i < 8; i++) {
		if (data & (1 << i)) {
			PORTB |= (1 << TX_PIN); // Enviar bit alto
			} else {
			PORTB &= ~(1 << TX_PIN); // Enviar bit bajo
		}
		_delay_us(GPIO_delay); // Esperar por el siguiente bit
	}

	PORTB |= (1 << TX_PIN); // Stop bit
	_delay_us(GPIO_delay); // Esperar antes de enviar el siguiente byte
}

uint8_t receiveByteGPIO() {
	uint8_t data = 0;

	// Esperar a que el pin RX (PB1) sea bajo (start bit)
	while (PINB & (1 << RX_PIN));

	_delay_us(GPIO_delay); // Esperar a que el primer bit se estabilice

	for (int i = 0; i < 8; i++) {
		if (PINB & (1 << RX_PIN)) {
			data |= (1 << i); // Leer bit
		}
		_delay_us(GPIO_delay); // Esperar por el siguiente bit
	}

	// Esperar a que el pin RX sea alto (stop bit)
	while (!(PINB & (1 << RX_PIN)));
	
	return data;
	}

void USART_Init() {
	UBRR0H = (MY_UBRR >> 8); // Configurar el registro de baudios alto
	UBRR0L = MY_UBRR;        // Configurar el registro de baudios bajo
	UCSR0B = (1 << RXEN0) | (1 << TXEN0); // Habilitar receptor y transmisor
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // 8 bits de datos, sin paridad, 1 bit de parada
}

void USART_Transmit(unsigned char data) {
	while (!(UCSR0A & (1 << UDRE0))); // Esperar hasta que el buffer esté vacío
	UDR0 = data; // Enviar el dato
}

unsigned char USART_Receive(void) {
	while (!(UCSR0A & (1 << RXC0))); // Esperar hasta que los datos estén disponibles
	return UDR0; // Leer el dato
}

void SendAT(uint8_t data){
		// Enviar un byte a través de PB0 (TX)
		PORTB &= ~(1 << TX_PIN); // Start bit
		_delay_us(AT_delay); // Esperar

		for (int i = 0; i < 8; i++) {
			if (data & (1 << i)) {
				PORTB |= (1 << TX_PIN); // Enviar bit alto
				} else {
				PORTB &= ~(1 << TX_PIN); // Enviar bit bajo
			}
			_delay_us(AT_delay); // Esperar por el siguiente bit
		}

		PORTB |= (1 << TX_PIN); // Stop bit
		_delay_us(AT_delay); // Esperar antes de enviar el siguiente byte

}

uint8_t ReceiveAT() {
	uint8_t data = 0;

	// Esperar a que el pin RX (PB1) sea bajo (start bit)
	while (PINB & (1 << RX_PIN));

	_delay_us(AT_delay); // Esperar a que el primer bit se estabilice

	for (int i = 0; i < 8; i++) {
		if (PINB & (1 << RX_PIN)) {
			data |= (1 << i); // Leer bit
		}
		_delay_us(AT_delay); // Esperar por el siguiente bit
	}

	// Esperar a que el pin RX sea alto (stop bit)
	while (!(PINB & (1 << RX_PIN)));
	
	return data;
}

int main() {
	// Inicializa la comunicación GPIO y USART
	initSerial();
	USART_Init();


	while (1) { 
		if (!(PINB & (1 << RX_PIN))) {
				uint8_t receivedGPIO = ReceiveAT();
				USART_Transmit(receivedGPIO); // Enviar el byte recibido al Monitor Serial
		}
		
		if (UCSR0A & (1 << RXC0)) {
				uint8_t receivedUSART = USART_Receive();
				SendAT(receivedUSART); // Enviar el byte recibido desde el Monitor Serial al HC-06
		}
		if(USART_Receive() == '|')
			break;
	}
	
	USART_Transmit('Y');
	
	while (1) {
		if (!(PINB & (1 << RX_PIN))) {
			uint8_t receivedGPIO = receiveByteGPIO();
			USART_Transmit(receivedGPIO); // Enviar el byte recibido al Monitor Serial
			
		}
		
		if (UCSR0A & (1 << RXC0)) {
			uint8_t receivedUSART = USART_Receive();
			sendByteGPIO(receivedUSART); // Enviar el byte recibido desde el Monitor Serial al HC-06
		} 

	}
	
	return 0;
}
